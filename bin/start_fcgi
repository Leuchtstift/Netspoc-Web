#!/usr/local/bin/perl

use strict;
use warnings;
use AnyEvent;
use FCGI;
use POSIX 'setsid';

my $VERSION = ( split ' ',
 '$Id$' )[2];

sub usage {
    die "Usage: $0 [IP]:PORT CMD ...\n";
}

my $listen = shift @ARGV or usage();
@ARGV or usage();
my $cmd = join(' ', @ARGV);

my $restart;
my $old_child;
my $new_child;

sub do_fork {
    if ($new_child) {
	warn "Still forking\n";
	return;
    }
    my $ppid = $$;
    my $child_fh;
    warn "Forking child\n";
    my $pid = fork;
    if (not defined $pid) {
	warn "Can't fork child: $!\n";
	return;
    }
    elsif ($pid) {
	
	# Parent process.
	$new_child = $pid;
 	return;
    }
    else {
			
	# Child process.
	# Start a fresh copy of this program which reads the changed data.
	# Tell child the ppid. Child sends signal when it's ready for requests.
	warn "Child $$ exec $cmd\n";
	$ENV{PPID} = $ppid;
        exec($cmd) or die "Can't exec '$cmd': $!\n";
    }
}

# Link STDIO with FCGI socket, will be used by child.
sub fcgi2stdin {
    my $sock = FCGI::OpenSocket($listen, 100)
	or die "failed to open FastCGI socket '$listen': $!"; 
    close STDIN;
    close STDOUT;
    open STDIN, "<&$sock" or die "Couldn't open STDIN to $listen: $!";
    open STDOUT, ">&$sock" or die "Couldn't open STDOUT to $listen: $!";
    select(STDOUT);
}

sub terminate {
    kill 'TERM', $old_child if $old_child;
    kill 'TERM', $new_child if $new_child;
    exit;
}

my $hup_watcher = AnyEvent->signal (signal => "HUP", 
				    cb => sub { warn "Got HUP\n";
						$restart->send });
my $term_watcher = AnyEvent->signal (signal => 'TERM', cb => \&terminate);
my $quit_watcher = AnyEvent->signal (signal => 'QUIT', cb => \&terminate);
my $int_watcher  = AnyEvent->signal (signal => 'INT', cb => \&terminate);


# Wait for some child to die.
my $child_died = AnyEvent->child 
    (
     pid => 0,
     cb  => sub {
	 my ($pid, $status) = @_;
	 warn "pid $pid exited with status $status\n";
	 if ($old_child && $pid eq $old_child) {
	     $old_child = undef;
	     $restart->send if not $new_child;
	 }
	 elsif ($new_child && $pid eq $new_child) {
	     $new_child = undef;
	     $restart->send if not $old_child;

	 }
     },
     );

# Wait for new child to be initialized.
my $child_OK = AnyEvent->signal 
    ( signal => "USR2", 
      cb => sub {
	  warn "Child is initialized\n";
	  if (my $pid = $old_child) {
	      $old_child = undef;;
	      kill 'TERM', $pid;
	  }
	  $old_child = $new_child;
	  $new_child = undef;
      });


# Daemonize.
fork && exit;
warn "FastCGI started (pid $$)\n";
fcgi2stdin();
POSIX::setsid();

while (1) {
    $restart = AnyEvent->condvar;
    do_fork($cmd);
    my $val = $restart->recv;
    warn "Restarting\n";
}

