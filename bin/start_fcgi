#!/usr/local/bin/perl

use strict;
use warnings;
use AnyEvent;
use FCGI;
use POSIX 'setsid';

my $VERSION = ( split ' ',
 '$Id$' )[2];

sub usage {
    die "Usage: $0 [IP]:PORT CMD ...\n";
}

my $listen = shift @ARGV or usage();
@ARGV or usage();
my $cmd = join(' ', @ARGV);

my $restart;
my $old_child;
my $new_child;

sub do_fork {
    if ($new_child->{pid}) {
	warn "Still forking\n";
	return;
    }
    my $ppid = $$;
    my $child_fh;
    warn "Forking child\n";
    defined (my $pid = fork) or die "Can't fork child: $!\n";
    if ($pid) {
	
	# Parent process.
	$new_child->{pid} = $pid;

	# Wait for new child to be initialized.
	my $child_OK;
	$child_OK = AnyEvent->signal 
	    ( signal => "USR2", 
	      cb => sub {
		  warn "Got SIGUSR2 child\n";
		  if (my $pid = $old_child->{pid}) {
		      kill 'TERM', $pid;
		      delete $old_child->{pid};
		  }
		  # this deletes $old_child->{w}; still needed?
		  $old_child = $new_child;
		  $new_child = undef;
		  $child_OK = undef;
	      });

 	# wait for new child to die.
	$new_child->{w} = AnyEvent->child 
	    (
	     pid => $pid,
	     cb  => sub {
		 my ($pid, $status) = @_;
		 warn "pid $pid exited with status $status";
		 if ($old_child->{pid} && $pid eq $old_child->{pid}) {
		     delete $old_child->{pid};
		     delete $old_child->{w};
		     $restart->send;
		 }
		 elsif ($new_child->{pid} && $pid eq $new_child->{pid}) {
		     delete $new_child->{pid};
		     delete $new_child->{w};
		     $restart->send if not $old_child->{pid};
		     
		 }
	     },
	     );

 	return;
    }
    else {
			
	# Child process.
	# Start a fresh copy of this program which reads the changed data.
	warn "Child $$ exec $cmd\n";
	$ENV{PPID} = $ppid;
        exec($cmd) or die "Can't exec '$cmd': $!\n";
    }
}

# Link STDIO with FCGI socket, will be used by child.
sub fcgi2stdin {
    my $sock = FCGI::OpenSocket($listen, 100)
	or die "failed to open FastCGI socket '$listen': $!"; 
    close STDIN;
    close STDOUT;
    open STDIN, "<&$sock" or die "Couldn't open STDIN to $listen: $!";
    open STDOUT, ">&$sock" or die "Couldn't open STDOUT to $listen: $!";
    select(STDOUT);
}

sub terminate {
    kill 'TERM', $old_child->{pid} if $old_child->{pid};
    kill 'TERM', $new_child->{pid} if $new_child->{pid};
    exit;
}

# Daemonize.
fork && exit;

warn "FastCGI started (pid $$)\n";
fcgi2stdin();
POSIX::setsid();
while (1) {
    $restart = AnyEvent->condvar;
    my $hup_watcher = AnyEvent->signal (signal => "HUP", 
					cb => sub {
					    warn "Got HUP\n";
					    $restart->send });
    my $term_watcher = AnyEvent->signal (signal => 'TERM', cb => \&terminate);
    my $quit_watcher = AnyEvent->signal (signal => 'QUIT', cb => \&terminate);
    my $int_watcher  = AnyEvent->signal (signal => 'INT', cb => \&terminate);
    do_fork($cmd);
    my $val = $restart->recv;
    warn "Restarting\n";
}

